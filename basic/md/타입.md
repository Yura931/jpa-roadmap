# 타입

## JPA 데이터 타입 분류
- 엔티티 타입
  - @Entity로 정의하는 객체
  - 데이터가 변해도 식별자로 지속해서 추적 가능
  - 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능
- 값 타입
  - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있으므로 변경시 추적 불가
  - 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체
  
  
### 값 타입 분류
- 기본 값 타입
  - 자바 기본 타입(int, double)
  - 래퍼 클래스(Integer, Long)
  - String
  - 예): String name, int age
  - 생명주기를 엔티티에 의존
    - 예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제
  - 값 타입은 공유하면X
    - 예) 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨
- 임베디드 타입(embedded type, 복합 값 타입, 내장타입)
  - 새로운 값 타입을 직접 정의할 수 있음
  - JPA는 임베디드 타입이라 함
  - int, String과 같은 값 타입, 추적도 안되고 변경하면 끝
  - 임베디드 타입과 테이블 매핑
  - 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능
  - 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.
- 컬렉션 값 타입(collection value type)


### 값타입과 불변객체
- 값 타입 공유 참조
  - 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험
  - side effect(부작용) 발생
  - 회원1과 회원2가 city를 임베디드 하고 있는데 이 city의 OldCity가 NewCity로 바뀌면 회원1과 회원2 전체가 변경되어버리는 상황이 발생
- 객체 타입의 한계
  - 자바 기본 타입은 값을 대입하면 값을 복사하지만 객체 타입은 참조값을 직접 대입하는 것이기 때문에 공유 참조를 피할 수 없다.
  - 불변 객체로 만들어 객체 타입을 수정할 수 없게 만들어 부작용을 원천 차단해야 한다.
  - 값 타입은 불변 객체(immutable object)로 설계해야함
  - 불변 객체: 생성 시점 이후 절대 값을 변경할 수 없는 객체
  - 생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨
  - 참고: Integer, String은 자바가 제공하는 대표적인 불변 객체


